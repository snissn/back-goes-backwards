<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>USCS Cannon-es Prototype with Guy Wires</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    let scene, camera, renderer, world;
    let deckBodies = [], deckMeshes = [], wires = [], spineSegments = [], spineMeshes = [], spineConstraints = [];

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 10, 30);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lighting
      scene.add(new THREE.DirectionalLight(0xffffff, 1).position.set(10, 20, 10));
      scene.add(new THREE.DirectionalLight(0xffffff, 0.5).position.set(-10, -10, -10));
      scene.add(new THREE.PointLight(0xffffff, 0.6).position.set(0, 15, 15));
      scene.add(new THREE.AmbientLight(0xffffff));

      world = new CANNON.World();
      world.gravity.set(0, -9.82, 0);

      const deckGeometry = new THREE.CylinderGeometry(3, 3, 0.5, 32);
      const deckMaterial = new THREE.MeshStandardMaterial({ color: 0x6699cc });
      const numDecks = 3;

      // Anchors for guy wires
      const anchors = [];
      const anchorOffsets = [
        [5, 0, 5], [-5, 0, 5], [5, 0, -5], [-5, 0, -5]
      ];
      for (const [x, y, z] of anchorOffsets) {
        const anchor = new CANNON.Body({ mass: 0 });
        anchor.position.set(x, y, z);
        world.addBody(anchor);
        anchors.push(anchor);
      }

      for (let i = 0; i < numDecks; i++) {
        const y = 5 + i * 5;
        const deckBody = new CANNON.Body({ mass: 1 });
        deckBody.addShape(new CANNON.Cylinder(3, 3, 0.5, 32));
        deckBody.position.set(0, y, 0);
        world.addBody(deckBody);
        deckBodies.push(deckBody);

        const deckMesh = new THREE.Mesh(deckGeometry, deckMaterial);
        scene.add(deckMesh);
        deckMeshes.push(deckMesh);

        // Guy wires to each corner
        for (let j = 0; j < anchors.length; j++) {
          const anchorVec = new CANNON.Vec3(...anchorOffsets[j]);
          wires.push(new CANNON.Spring(deckBody, anchors[j], {
            localAnchorA: new CANNON.Vec3(anchorVec.x > 0 ? 2.5 : -2.5, -0.25, anchorVec.z > 0 ? 2.5 : -2.5),
            localAnchorB: new CANNON.Vec3(0, 0, 0),
            restLength: Math.sqrt(anchorVec.x**2 + y**2 + anchorVec.z**2),
            stiffness: 100,
            damping: 2
          }));
        }
      }

      for (let i = 1; i < deckBodies.length; i++) {
        wires.push(new CANNON.Spring(deckBodies[i], deckBodies[i - 1], {
          localAnchorA: new CANNON.Vec3(0, -0.25, 0),
          localAnchorB: new CANNON.Vec3(0, 0.25, 0),
          restLength: 5,
          stiffness: 200,
          damping: 2
        }));
      }

      const spineMaterial = new THREE.MeshStandardMaterial({ color: 0xff8844 });
      const spineGeom = new THREE.CylinderGeometry(0.3, 0.3, 1, 16);
      const numSpineSegments = 5;

      for (let i = 0; i < numSpineSegments; i++) {
        const y = 5 + i * 2;
        const seg = new CANNON.Body({ mass: 0.2 });
        seg.addShape(new CANNON.Cylinder(0.3, 0.3, 1, 16));
        seg.position.set(0, y, 0);
        world.addBody(seg);
        spineSegments.push(seg);

        const mesh = new THREE.Mesh(spineGeom, spineMaterial);
        scene.add(mesh);
        spineMeshes.push(mesh);

        if (i > 0) {
          const constraint = new CANNON.LockConstraint(spineSegments[i], spineSegments[i - 1]);
          world.addConstraint(constraint);
          spineConstraints.push(constraint);
        }
      }

      wires.push(
        new CANNON.Spring(spineSegments[numSpineSegments - 1], deckBodies[2], {
          localAnchorA: new CANNON.Vec3(0, 0.5, 0),
          localAnchorB: new CANNON.Vec3(0, -0.25, 0),
          restLength: 2.5,
          stiffness: 100,
          damping: 1
        }),
        new CANNON.Spring(spineSegments[0], deckBodies[0], {
          localAnchorA: new CANNON.Vec3(0, -0.5, 0),
          localAnchorB: new CANNON.Vec3(0, 0.25, 0),
          restLength: 2.5,
          stiffness: 100,
          damping: 1
        })
      );

      const groundBody = new CANNON.Body({ mass: 0 });
      groundBody.addShape(new CANNON.Plane());
      groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(groundBody);
    }

    function animate() {
      requestAnimationFrame(animate);
      world.step(1 / 60);

      for (let i = 0; i < deckBodies.length; i++) {
        deckMeshes[i].position.copy(deckBodies[i].position);
        deckMeshes[i].quaternion.copy(deckBodies[i].quaternion);
      }

      for (let i = 0; i < spineSegments.length; i++) {
        spineMeshes[i].position.copy(spineSegments[i].position);
        spineMeshes[i].quaternion.copy(spineSegments[i].quaternion);
      }

      for (const wire of wires) wire.applyForce();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>


