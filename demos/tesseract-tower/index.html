<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Elastic Cube Tower Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.157.0';
    import { OrbitControls } from 'https://esm.sh/three@0.157.0/examples/jsm/controls/OrbitControls.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    let scene, camera, renderer, world, controls;
    let innerCornerBodies = [], innerSprings = [], innerSpringLines = [], connectorSprings = [], connectorLines = [], outerSprings = [], outerSpringLines = [], outerCornerVisuals = [];
    let time = 0;

    const outerSize = 4;
    const outerAspect = { x: 1, y: 2, z: 1 };
    const innerSize = 1.5;
    const innerAspect = { x: 1, y: 2, z: 1 };

    const outerPoints = [];
const anchorBodies = [];
const anchorSprings = [];

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(8, 8, 8);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.update();

      world = new CANNON.World({ gravity: new CANNON.Vec3(0, 0, 0) });

      const half = outerSize / 2;
      const outerPointsRaw = [
        [-half * outerAspect.x, half * outerAspect.y, -half * outerAspect.z],
        [ half * outerAspect.x, half * outerAspect.y, -half * outerAspect.z],
        [-half * outerAspect.x, half * outerAspect.y,  half * outerAspect.z],
        [ half * outerAspect.x, half * outerAspect.y,  half * outerAspect.z],
        [-half * outerAspect.x, -half * outerAspect.y, -half * outerAspect.z],
        [ half * outerAspect.x, -half * outerAspect.y, -half * outerAspect.z],
        [-half * outerAspect.x, -half * outerAspect.y,  half * outerAspect.z],
        [ half * outerAspect.x, -half * outerAspect.y,  half * outerAspect.z]
      ];

      outerPointsRaw.forEach((pos, index) => {
  const isBottom = index >= 4;
  const v = new CANNON.Body({ mass: isBottom ? 0 : 0.1 });
  v.position.set(...pos);

  if (index === 4 || index === 5) {
    v.type = CANNON.Body.STATIC;
    v.linearFactor = new CANNON.Vec3(0, 0, 0);
    v.angularFactor = new CANNON.Vec3(0, 0, 0);
  }

  if (index === 0 || index === 1) {
    const anchor = new CANNON.Body({ mass: 0 });
    anchor.position.set(...pos);
    world.addBody(anchor);
    anchorBodies.push(anchor);
    const lock = new CANNON.LockConstraint(v, anchor);
    world.addConstraint(lock);
    anchorSprings.push({ body: v, anchor });
  }
});
  }

    world.addBody(v);
  outerPoints.push(v);
  const sphere = new THREE.Mesh(
    new THREE.SphereGeometry(0.05),
    new THREE.MeshBasicMaterial({ color: 0xff0000 })
  );
  sphere.userData.body = v;
  scene.add(sphere);
  outerCornerVisuals.push(sphere);
        world.addBody(v);
  outerPoints.push(v);

  const sphere = new THREE.Mesh(
    new THREE.SphereGeometry(0.05),
    new THREE.MeshBasicMaterial({ color: 0xff0000 })
  );
  sphere.userData.body = v;
  scene.add(sphere);
  outerCornerVisuals.push(sphere);
});

// Add markers for posterior and ventral sides
      const posteriorMarker = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.1, 0.1),
        new THREE.MeshBasicMaterial({ color: 0x0000ff }) // Blue = posterior
      );
      posteriorMarker.position.set(0, 0, -outerSize * 0.6);
      scene.add(posteriorMarker);

      const ventralMarker = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.1, 0.1),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 }) // Green = ventral
      );
      ventralMarker.position.set(0, 0, outerSize * 0.6);
      scene.add(ventralMarker);

      const edgeIndices = [
        [0, 1], [1, 3], [3, 2], [2, 0],
        [4, 5], [5, 7], [7, 6], [6, 4],
        [0, 4], [1, 5], [2, 6], [3, 7]
      ];

      edgeIndices.forEach(([a, b]) => {
        const posA = outerPoints[a].position;
        const posB = outerPoints[b].position;
        const restLength = posA.distanceTo(posB);
        const spring = new CANNON.Spring(outerPoints[a], outerPoints[b], {
          restLength,
          stiffness: 100,
          damping: 2.0
        });
        outerSprings.push(spring);

        const geo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(), new THREE.Vector3()
        ]);
        const mat = new THREE.LineBasicMaterial({ color: 0xffaa00 });
        const line = new THREE.Line(geo, mat);
        outerSpringLines.push(line);
        scene.add(line);
      });

      const halfInner = innerSize / 2;
      const innerOffsets = [
  // Posterior top (closer to Z-) - remains aligned
  [-halfInner * innerAspect.x, halfInner * innerAspect.y, -half * outerAspect.z + 0.3],
  [ halfInner * innerAspect.x, halfInner * innerAspect.y, -half * outerAspect.z + 0.3],
  // Ventral top (Z+) - start lower to simulate convex drop
  [-halfInner * innerAspect.x, halfInner * innerAspect.y, -half * outerAspect.z + 0.3 + innerSize - 0.3],
  [ halfInner * innerAspect.x, halfInner * innerAspect.y, -half * outerAspect.z + 0.3 + innerSize - 0.3],
  // Posterior bottom
  [-halfInner * innerAspect.x, -halfInner * innerAspect.y, -half * outerAspect.z + 0.3],
  [ halfInner * innerAspect.x, -halfInner * innerAspect.y, -half * outerAspect.z + 0.3],
  // Ventral bottom
  [-halfInner * innerAspect.x, -halfInner * innerAspect.y, -half * outerAspect.z + 0.3 + innerSize],
  [ halfInner * innerAspect.x, -halfInner * innerAspect.y, -half * outerAspect.z + 0.3 + innerSize]
];

      innerOffsets.forEach(offset => {
        const body = new CANNON.Body({ mass: 0.1 });
        body.position.set(offset[0], offset[1], offset[2]);
        world.addBody(body);

        const sphere = new THREE.Mesh(
          new THREE.SphereGeometry(0.03),
          new THREE.MeshBasicMaterial({ color: 0x00ffff })
        );
        sphere.userData.body = body;
        scene.add(sphere);
        innerCornerBodies.push({ body, visual: sphere });
      });

      const innerEdgeIndices = [
        [0,1],[1,3],[3,2],[2,0],
        [4,5],[5,7],[7,6],[6,4],
        [0,4],[1,5],[2,6],[3,7]
      ];

      innerEdgeIndices.forEach(([a,b]) => {
        const posA = innerCornerBodies[a].body.position;
        const posB = innerCornerBodies[b].body.position;
        const restLength = posA.distanceTo(posB);
        const spring = new CANNON.Spring(innerCornerBodies[a].body, innerCornerBodies[b].body, {
          restLength,
          stiffness: 30,
          damping: 1.5
        });
        innerSprings.push(spring);

        const geo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(), new THREE.Vector3()
        ]);
        const mat = new THREE.LineBasicMaterial({ color: 0xffff00 });
        const line = new THREE.Line(geo, mat);
        innerSpringLines.push(line);
        scene.add(line);
      });

      innerCornerBodies.forEach((corner, i) => {
        const outer = outerPoints[i];
        const spring = new CANNON.Spring(corner.body, outer, {
          restLength: 0.1,
          stiffness: 50,
          damping: 1.5
        });
        connectorSprings.push(spring);

        const geo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(), new THREE.Vector3()
        ]);
        const mat = new THREE.LineBasicMaterial({ color: 0x00ffcc });
        const line = new THREE.Line(geo, mat);
        connectorLines.push(line);
        scene.add(line);
      });

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 7);
      scene.add(light);
    }

    function animate() {
  requestAnimationFrame(animate);
      time += 0.016;

      innerSprings.forEach(s => s.applyForce());

      connectorSprings.forEach((spring, i) => {
        const amp = i < 4 ? Math.sin(time) : Math.cos(time);
        spring.stiffness = 50 + 20 * amp;
        spring.applyForce();
      });

      outerSprings.forEach(s => s.applyForce());
anchorSprings.forEach(({ body, anchor }) => {
  anchor.position.z = body.position.z;
});

  // Constraint override removed â€” using anchor springs instead

      world.step(1 / 60);

      innerCornerBodies.forEach(p => {
        p.visual.position.copy(p.body.position);
      });

      outerCornerVisuals.forEach(sphere => {
        sphere.position.copy(sphere.userData.body.position);
      });

      innerSpringLines.forEach((line, i) => {
        const s = innerSprings[i];
        const a = s.bodyA.position;
        const b = s.bodyB.position;
        line.geometry.setFromPoints([
          new THREE.Vector3(a.x, a.y, a.z),
          new THREE.Vector3(b.x, b.y, b.z)
        ]);
      });

      connectorLines.forEach((line, i) => {
        const spring = connectorSprings[i];
        const a = spring.bodyA.position;
        const b = spring.bodyB.position;
        line.geometry.setFromPoints([
          new THREE.Vector3(a.x, a.y, a.z),
          new THREE.Vector3(b.x, b.y, b.z)
        ]);
      });

      outerSpringLines.forEach((line, i) => {
        const spring = outerSprings[i];
        const a = spring.bodyA.position;
        const b = spring.bodyB.position;
        line.geometry.setFromPoints([
          new THREE.Vector3(a.x, a.y, a.z),
          new THREE.Vector3(b.x, b.y, b.z)
        ]);
      });

      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>


